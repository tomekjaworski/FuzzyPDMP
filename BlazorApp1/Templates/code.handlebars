#
# Zbiór modeli wygenerowany przez BlazorApp1
# Znacznik czasowy generacji: {{CurrentDate}}
#
# Zażółć gęsią jaźń ZAŻÓŁĆ GĘSIĄ JAŹŃ

import numpy as np
import skfuzzy as fuzz
import matplotlib.pyplot as plt
from typing import List, Union


class FuzzyOperation(object):
    or_connective = None
    and_connective = None
    negation = None

    def __init__(self, or_connective = None, and_connective = None, negation = None):
        self.or_connective = or_connective or (lambda x, y: x if x > y else y)
        self.and_connective = and_connective or (lambda x, y: x if x < y else y)
        self.negation = lambda x: 1 - x


    def AND(self, *args):
        if len(args) == 0:
            raise ValueError("args")
        elif len(args) == 1:
            return self.and_connective(args[0], args[1])
        v = args[0]
        for i in range(1, len(args)):
            v = self.and_connective(v, args[i])
        return v

    def OR(self, *args):
        if len(args) == 0:
            raise ValueError("args")
        elif len(args) == 1:
            return self.or_connective(args[0], args[1])
        v = args[0]
        for i in range(1, len(args)):
            v = self.or_connective(v, args[i])
        return v

    def NOT(self, *args):
        if len(args) != 1:
            raise ValueError("args")
        return self.negation(args[0])


## -------------------------------------------------------------------------

{{#each Models}}
##
## Model: {{{ModelName}}}
## Opis:  {{{ModelDescription}}}
##
{{#if IsValid}}
class Model_{{normalize ModelName}}(object):
    foper = None #type: FuzzyOperation

    # Wartości ostre dla zmiennych wejściowych
{{#each InputVariables}}
    input_{{normalize Name}} = None # type: float # Zmienna: {{{Name}}}
{{/each}}

    # Wartości ostre dla zmiennych wyjściowych
{{#each OutputVariables}}
    output_{{normalize Name}} = None # type: float # Zmienna: {{{Name}}}
{{/each}}

    # Dziedziny zmiennych rozmytych
{{#each InputVariables}}
    x_{{normalize Name}} = None # type: Union[List[float], np.ndarray]
{{/each}}
{{#each OutputVariables}}
    x_{{normalize Name}} = None # type: Union[List[float], np.ndarray]
{{/each}}

    # Wartości przynależności
{{#each AllValues}}
    memb_{{normalize Variable.Name}}_{{normalize Name}} = None # type: Union[List[float], np.ndarray]
{{/each}}

    def __init__(self):
        self.foper = FuzzyOperation()

        self.InitDomain()
        self.InitVariables()
#       self.ShowVariables()

    def InitDomain(self):
{{#each InputVariables}}
        self.x_{{normalize Name}} = np.arange({{D4 Minimum.Value}}, {{D4 Maximum.Value}}, {{D4 ../XStep}}) # {{{Name}}}: {{{Description}}}
{{/each}}
{{#each OutputVariables}}
        self.x_{{normalize Name}} = np.arange({{D4 Minimum.Value}}, {{D4 Maximum.Value}}, {{D4 ../XStep}}) # {{{Name}}}: {{{Description}}}
{{/each}}

    def InitVariables(self):
{{#each InputVariables}}

        # Wejście: {{Name}}
{{#each Values}}
        self.memb_{{normalize Variable.Name}}_{{normalize Name}} = fuzz.trapmf(self.x_{{normalize Variable.Name}}, [{{D4 MembershipParameters.SuppL.Value}}, {{D4 MembershipParameters.KernL.Value}}, {{D4 MembershipParameters.KernR.Value}}, {{D4 MembershipParameters.SuppR.Value}}])
{{/each}}
{{/each}}

{{#each OutputVariables}}
        # Wyjście: {{Name}}{{#each Values}}
        self.memb_{{normalize Variable.Name}}_{{normalize Name}} = fuzz.trapmf(self.x_{{normalize Variable.Name}}, [{{D4 MembershipParameters.SuppL.Value}}, {{D4 MembershipParameters.KernL.Value}}, {{D4 MembershipParameters.KernR.Value}}, {{D4 MembershipParameters.SuppR.Value}}])
{{~/each}}{{/each}}

  def Execute(self, {{#each InputVariables}}{{#if @index}}, {{/if}}input_{{normalize Name}}: float{{/each}}):
{{#each InputVariables}}
        self.input_{{normalize Name}} = input_{{normalize Name}}
{{/each}}

        # Wyznacz poziomy przynależności
{{~#each InputVariables}}{{#each Values}}
        level_{{normalize Variable.Name}}_{{normalize Name}} = fuzz.interp_membership(self.x_{{normalize Variable.Name}}, self.memb_{{normalize Variable.Name}}_{{normalize Name}}, self.input_{{normalize Variable.Name}})
{{~/each}}{{/each}}

        #
        # Tutaj wnioskowanie ....
{{#each CompiledRules}}

        # Reguła {{Comment}}
{{#each Operations}}
{{#if Op.IsAnd}}
        {{Target.Name}} = self.foper.AND({{#if Left.IsFuzzyValue}}level_{{normalize Left.FuzzyValue.Variable.Name}}_{{normalize Left.FuzzyValue.Name}}{{/if}}{{#if Left.IsNamedVariable}}{{Left.Name}}{{/if}}, {{#if Right.IsFuzzyValue}}level_{{normalize Right.FuzzyValue.Variable.Name}}_{{normalize Right.FuzzyValue.Name}}{{/if}}{{#if Right.IsNamedVariable}}{{Right.Name}}{{/if}})
{{/if~}}{{#if Op.IsOr}}
        {{Target.Name}} = self.foper.OR({{#if Left.IsFuzzyValue}}level_{{normalize Left.FuzzyValue.Variable.Name}}_{{normalize Left.FuzzyValue.Name}}{{/if}}{{#if Left.IsNamedVariable}}{{Left.Name}}{{/if}}, {{#if Right.IsFuzzyValue}}level_{{normalize Right.FuzzyValue.Variable.Name}}_{{normalize Right.FuzzyValue.Name}}{{/if}}{{#if Right.IsNamedVariable}}{{Right.Name}}{{/if}})
{{~/if}}{{/each}}
        rule_{{@index}} = {{FinalToken.Name}}
{{/each}}


{{~#each OutputVariables}}{{#each Values}}
        self.output_{{normalize Variable.Name}}_{{normalize Name}} = 123 # todo: ....
{{~/each}}{{/each}}



    def ShowVariables(self):
        fig, axes = plt.subplots(nrows={{InputVariables.Length}} + {{OutputVariables.Length}}, figsize=(8, 3 * ({{InputVariables.Length}} + {{OutputVariables.Length}})))
        if not hasattr(axis, "__len__"):
            axes = [axes]
{{#each InputVariables}}{{#each Values}}
        axes[{{@../index}}].plot(self.x_{{normalize ../Name}}, self.memb_{{normalize ../Name}}_{{normalize Name}}, '{{color @index}}', linewidth=1.5, label='{{{Name}}}'){{/each}}
        axes[{{@index}}].set_title('WE: {{Description}}')
        axes[{{@index}}].legend()
{{/each}}
{{#each OutputVariables}}{{#each Values}}
        axes[{{@../index}}].plot(self.x_{{normalize ../Name}}, self.memb_{{normalize ../Name}}_{{normalize Name}}, '{{color @index}}', linewidth=1.5, label='{{{Name}}}'){{/each}}
        axes[{{@index}}].set_title('WY: {{Description}}')
        axes[{{@index}}].legend()
{{/each}}

        # Turn off top/right axes
        for ax in axes:
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)
            ax.get_xaxis().tick_bottom()
            ax.get_yaxis().tick_left()

        plt.tight_layout()
        plt.show()
{{else}}
## Model {{ModelName}} jest niedokończony.
##
{{/if}}

{{/each}}
if __name__ == "__main__":
{{#each Models}}
{{#unless IsValid}}#{{/unless}}    m{{@Index}} = Model_{{normalize ModelName}}()
{{#unless IsValid}}#{{/unless}}    m{{@Index}}.ShowVariables()

{{/each}}
